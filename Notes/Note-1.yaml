Flow of execution
1. Configure provider (aws, region)
2. Create VPC resource (cidr_block, tags)
3. Create subnet resource (vpc_id, cidr_block, availability_zone, tags)
4. Create internet_gateway resource (vpc_id, tags)
5. Create route_table resource (default_route_table_id(= default) or vpc_id(!= Default), route(cidr_block=[0.0.0.0/0], gateway_id), tags)
   >> If not using default_route_table:
      we have to create aws_route_table_association (subnet_id, route_table_id)
6. Create security_group resource (vpc_id, ingress(from_port, to_port, protocol, cidr_blocks), egress(same as ingress), tags)
7. Create key_pair resource (key_name, public_key)
8. Create instance resource (ami, subnet_id, vpc_security_group_ids/security_group, availability_zone, associate_public_ip_address, key_name, user_data(for bootstraping the instance), tags )
   >> For Provisioner Implementation:
      connection (type, host, user, private_key)
      Create provisioner "file" (source, destination)
      Create provisioner "remote-exec" (script)
      Create provisioner "local-exec" (command)



Recreate resource
terraform apply -replace="<resourceName>.<localName>" 

Variables
on command line 
-var ="VARIABLENAME=VALUE"
-var-file = "FILEPATH"

tfvars.tf file

ENV_VARIABLE
TF_VAR_VARIABLE_NAME="VALUE"

ssh-keygen -t rsa -b 2048 -C 'ssh key' -N '' -f ~/.ssh/ssh_rsa

output "ec2_publicIP" {
    values=aws_instance.server1.public_ip
    description= "public ip"
   sensitive = ture (default false)
}

command: 
terraform output 
terraform output <outputName>
terraform output -json > output.json

Statefile
command:
terrafom show
terraform show | grep -A 20 aws_vpc
terraform state list 
terraform state show aws_instance.my_vm

Replace resource without destroying the whole infrastructure
terraform plan -replace="aws_instance.my_vm" (shows the resource to be replaced)
terraform apply -replace="aws_instance.my_vm" --auto-approve

 Running Commands on EC2
user_data
cloud-init
Packer
Provisioners

Difference btw user_data and provisioners
user_data is native to the cloud provider and provisioners are native to Terraform
Provisioners are a last resort and should be used with care

Provisioners:
connection {
  type= "ssh"
  host = self.public_ip
  user = ec2-user
  private_key = file(var.private_key_path)
}

provisioner "file" {
  source = "./entry-script.sh"
  destination = "/home/ec2-user/entry-script.sh"
}
provisioner "remote-exec" {
  inline = [
  sudo -i,
  ls -la
  ]
}


Troubleshooting Terraform Script

terraform fmt
terraform validate

Enable detailed logging
TF_LOG=DEBUG/TRACE/INFO/WARN OR ERROR
TF_LOG_PATH=terraform.log (Saving output to a file)

TF_LOG_CORE=INFO
TF_LOG_PROVIDER=TRACE

Logging options
- DEBUG
- TRACE
- INFO
- WARN
- ERROR

